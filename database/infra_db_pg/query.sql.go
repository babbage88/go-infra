// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package infra_db_pg

import (
	"context"
	"net/netip"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createExternalApplication = `-- name: CreateExternalApplication :one
INSERT INTO public.external_integration_apps (id, "name", endpoint_url, app_description) 
VALUES ($1, $2, $3, $4)
RETURNING id, "name", created_at, last_modified, endpoint_url, app_description
`

type CreateExternalApplicationParams struct {
	ID             uuid.UUID
	Name           string
	EndpointUrl    pgtype.Text
	AppDescription pgtype.Text
}

func (q *Queries) CreateExternalApplication(ctx context.Context, arg CreateExternalApplicationParams) (ExternalIntegrationApp, error) {
	row := q.db.QueryRow(ctx, createExternalApplication,
		arg.ID,
		arg.Name,
		arg.EndpointUrl,
		arg.AppDescription,
	)
	var i ExternalIntegrationApp
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.LastModified,
		&i.EndpointUrl,
		&i.AppDescription,
	)
	return i, err
}

const createHostServer = `-- name: CreateHostServer :one
INSERT INTO public.host_servers (
    hostname,
    ip_address,
    is_container_host,
    is_vm_host,
    is_virtual_machine,
    id_db_host
) VALUES (
    $1, $2, $3, $4, $5, $6
)
ON CONFLICT (hostname, ip_address) DO UPDATE SET
    is_container_host = EXCLUDED.is_container_host,
    is_vm_host = EXCLUDED.is_vm_host,
    is_virtual_machine = EXCLUDED.is_virtual_machine,
    id_db_host = EXCLUDED.id_db_host,
    last_modified = CURRENT_TIMESTAMP
RETURNING id, hostname, ip_address, is_container_host, is_vm_host, is_virtual_machine, id_db_host, created_at, last_modified
`

type CreateHostServerParams struct {
	Hostname         string
	IpAddress        netip.Addr
	IsContainerHost  pgtype.Bool
	IsVmHost         pgtype.Bool
	IsVirtualMachine pgtype.Bool
	IDDbHost         pgtype.Bool
}

type CreateHostServerRow struct {
	ID               uuid.UUID
	Hostname         string
	IpAddress        netip.Addr
	IsContainerHost  pgtype.Bool
	IsVmHost         pgtype.Bool
	IsVirtualMachine pgtype.Bool
	IDDbHost         pgtype.Bool
	CreatedAt        pgtype.Timestamptz
	LastModified     pgtype.Timestamptz
}

// Host Servers CRUD Operations
func (q *Queries) CreateHostServer(ctx context.Context, arg CreateHostServerParams) (CreateHostServerRow, error) {
	row := q.db.QueryRow(ctx, createHostServer,
		arg.Hostname,
		arg.IpAddress,
		arg.IsContainerHost,
		arg.IsVmHost,
		arg.IsVirtualMachine,
		arg.IDDbHost,
	)
	var i CreateHostServerRow
	err := row.Scan(
		&i.ID,
		&i.Hostname,
		&i.IpAddress,
		&i.IsContainerHost,
		&i.IsVmHost,
		&i.IsVirtualMachine,
		&i.IDDbHost,
		&i.CreatedAt,
		&i.LastModified,
	)
	return i, err
}

const createSSHKey = `-- name: CreateSSHKey :one
INSERT INTO public.ssh_keys (
    name,
    description,
    priv_secret_id,
    public_key,
    key_type_id,
    owner_user_id
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, name, description, priv_secret_id, public_key, key_type_id, owner_user_id, created_at, last_modified
`

type CreateSSHKeyParams struct {
	Name         string
	Description  pgtype.Text
	PrivSecretID pgtype.UUID
	PublicKey    string
	KeyTypeID    uuid.UUID
	OwnerUserID  uuid.UUID
}

type CreateSSHKeyRow struct {
	ID           uuid.UUID
	Name         string
	Description  pgtype.Text
	PrivSecretID pgtype.UUID
	PublicKey    string
	KeyTypeID    uuid.UUID
	OwnerUserID  uuid.UUID
	CreatedAt    pgtype.Timestamptz
	LastModified pgtype.Timestamptz
}

// SSH Keys CRUD Operations
func (q *Queries) CreateSSHKey(ctx context.Context, arg CreateSSHKeyParams) (CreateSSHKeyRow, error) {
	row := q.db.QueryRow(ctx, createSSHKey,
		arg.Name,
		arg.Description,
		arg.PrivSecretID,
		arg.PublicKey,
		arg.KeyTypeID,
		arg.OwnerUserID,
	)
	var i CreateSSHKeyRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.PrivSecretID,
		&i.PublicKey,
		&i.KeyTypeID,
		&i.OwnerUserID,
		&i.CreatedAt,
		&i.LastModified,
	)
	return i, err
}

const createSSHKeyHostMapping = `-- name: CreateSSHKeyHostMapping :one
INSERT INTO public.host_server_ssh_mappings (
    host_server_id,
    ssh_key_id,
    user_id,
    hostserver_username,
    sudo_password_token_id
) VALUES (
    $1, $2, $3, $4, $5
)
ON CONFLICT (host_server_id, ssh_key_id) DO UPDATE SET
    hostserver_username = EXCLUDED.hostserver_username,
    user_id = EXCLUDED.user_id,
    sudo_password_token_id = EXCLUDED.sudo_password_token_id,
    last_modified = CURRENT_TIMESTAMP
RETURNING id, host_server_id, ssh_key_id, user_id, hostserver_username, sudo_password_token_id, created_at, last_modified
`

type CreateSSHKeyHostMappingParams struct {
	HostServerID        uuid.UUID
	SshKeyID            uuid.UUID
	UserID              uuid.UUID
	HostserverUsername  string
	SudoPasswordTokenID pgtype.UUID
}

type CreateSSHKeyHostMappingRow struct {
	ID                  uuid.UUID
	HostServerID        uuid.UUID
	SshKeyID            uuid.UUID
	UserID              uuid.UUID
	HostserverUsername  string
	SudoPasswordTokenID pgtype.UUID
	CreatedAt           pgtype.Timestamptz
	LastModified        pgtype.Timestamptz
}

// SSH Key to Host Server Mappings CRUD Operations
func (q *Queries) CreateSSHKeyHostMapping(ctx context.Context, arg CreateSSHKeyHostMappingParams) (CreateSSHKeyHostMappingRow, error) {
	row := q.db.QueryRow(ctx, createSSHKeyHostMapping,
		arg.HostServerID,
		arg.SshKeyID,
		arg.UserID,
		arg.HostserverUsername,
		arg.SudoPasswordTokenID,
	)
	var i CreateSSHKeyHostMappingRow
	err := row.Scan(
		&i.ID,
		&i.HostServerID,
		&i.SshKeyID,
		&i.UserID,
		&i.HostserverUsername,
		&i.SudoPasswordTokenID,
		&i.CreatedAt,
		&i.LastModified,
	)
	return i, err
}

const createSSHKeyType = `-- name: CreateSSHKeyType :one
INSERT INTO public.ssh_key_types (
    name,
    description
) VALUES (
    $1, $2
) RETURNING id, name, description, created_at, last_modified
`

type CreateSSHKeyTypeParams struct {
	Name        string
	Description pgtype.Text
}

func (q *Queries) CreateSSHKeyType(ctx context.Context, arg CreateSSHKeyTypeParams) (SshKeyType, error) {
	row := q.db.QueryRow(ctx, createSSHKeyType, arg.Name, arg.Description)
	var i SshKeyType
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.LastModified,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    username,
    password,
    email
) VALUES (
  $1, $2, $3
)
RETURNING id, username, password, email, created_at, last_modified, enabled, is_deleted
`

type CreateUserParams struct {
	Username pgtype.Text
	Password pgtype.Text
	Email    pgtype.Text
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Username, arg.Password, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.CreatedAt,
		&i.LastModified,
		&i.Enabled,
		&i.IsDeleted,
	)
	return i, err
}

const dbHealthCheckRead = `-- name: DbHealthCheckRead :one
SELECT id, status, check_type
FROM public.health_check WHERE check_type = 'Read'
LIMIT 1
`

type DbHealthCheckReadRow struct {
	ID        int32
	Status    pgtype.Text
	CheckType pgtype.Text
}

func (q *Queries) DbHealthCheckRead(ctx context.Context) (DbHealthCheckReadRow, error) {
	row := q.db.QueryRow(ctx, dbHealthCheckRead)
	var i DbHealthCheckReadRow
	err := row.Scan(&i.ID, &i.Status, &i.CheckType)
	return i, err
}

const deleteExpiredAuthTokens = `-- name: DeleteExpiredAuthTokens :exec
DELETE FROM external_auth_tokens
WHERE expiration < CURRENT_TIMESTAMP AT TIME ZONE 'UTC'
`

func (q *Queries) DeleteExpiredAuthTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredAuthTokens)
	return err
}

const deleteExternalApplicationById = `-- name: DeleteExternalApplicationById :exec
DELETE FROM external_integration_apps
WHERE id = $1
`

func (q *Queries) DeleteExternalApplicationById(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteExternalApplicationById, id)
	return err
}

const deleteExternalApplicationByName = `-- name: DeleteExternalApplicationByName :exec
DELETE FROM external_integration_apps
WHERE "name" = $1
`

func (q *Queries) DeleteExternalApplicationByName(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, deleteExternalApplicationByName, name)
	return err
}

const deleteExternalAuthTokenById = `-- name: DeleteExternalAuthTokenById :exec
DELETE FROM external_auth_tokens
WHERE id = $1
`

func (q *Queries) DeleteExternalAuthTokenById(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteExternalAuthTokenById, id)
	return err
}

const deleteHostServer = `-- name: DeleteHostServer :exec
DELETE FROM public.host_servers
WHERE id = $1
`

func (q *Queries) DeleteHostServer(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteHostServer, id)
	return err
}

const deleteSSHKey = `-- name: DeleteSSHKey :exec
DELETE FROM public.ssh_keys
WHERE id = $1
`

func (q *Queries) DeleteSSHKey(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSSHKey, id)
	return err
}

const deleteSSHKeyHostMapping = `-- name: DeleteSSHKeyHostMapping :exec
DELETE FROM public.host_server_ssh_mappings
WHERE id = $1
`

func (q *Queries) DeleteSSHKeyHostMapping(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSSHKeyHostMapping, id)
	return err
}

const deleteSSHKeyHostMappingsBySshKeyId = `-- name: DeleteSSHKeyHostMappingsBySshKeyId :exec
DELETE FROM public.host_server_ssh_mappings
WHERE ssh_key_id = $1
`

func (q *Queries) DeleteSSHKeyHostMappingsBySshKeyId(ctx context.Context, sshKeyID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSSHKeyHostMappingsBySshKeyId, sshKeyID)
	return err
}

const deleteSSHKeyType = `-- name: DeleteSSHKeyType :exec
DELETE FROM public.ssh_key_types
WHERE name = $1
`

func (q *Queries) DeleteSSHKeyType(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, deleteSSHKeyType, name)
	return err
}

const deleteUserById = `-- name: DeleteUserById :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DeleteUserById(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserById, id)
	return err
}

const disableUserById = `-- name: DisableUserById :one
UPDATE users
  set "enabled" = $2
WHERE id = $1
RETURNING id, username, password, email, created_at, last_modified, enabled, is_deleted
`

type DisableUserByIdParams struct {
	ID      uuid.UUID
	Enabled bool
}

func (q *Queries) DisableUserById(ctx context.Context, arg DisableUserByIdParams) (User, error) {
	row := q.db.QueryRow(ctx, disableUserById, arg.ID, arg.Enabled)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.CreatedAt,
		&i.LastModified,
		&i.Enabled,
		&i.IsDeleted,
	)
	return i, err
}

const disableUserRoleById = `-- name: DisableUserRoleById :exec
UPDATE user_roles SET "enabled" = FALSE
WHERE id = $1
`

func (q *Queries) DisableUserRoleById(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, disableUserRoleById, id)
	return err
}

const disableUserRoleMappingById = `-- name: DisableUserRoleMappingById :one
UPDATE
  public.user_role_mapping
SET
  enabled = FALSE
WHERE user_id = $1 AND role_id = $2
RETURNING id, user_id, role_id, enabled, created_at, last_modified
`

type DisableUserRoleMappingByIdParams struct {
	UserID uuid.UUID
	RoleID uuid.UUID
}

func (q *Queries) DisableUserRoleMappingById(ctx context.Context, arg DisableUserRoleMappingByIdParams) (UserRoleMapping, error) {
	row := q.db.QueryRow(ctx, disableUserRoleMappingById, arg.UserID, arg.RoleID)
	var i UserRoleMapping
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RoleID,
		&i.Enabled,
		&i.CreatedAt,
		&i.LastModified,
	)
	return i, err
}

const enableUserById = `-- name: EnableUserById :one
UPDATE users
  set "enabled" = $2
WHERE id = $1
RETURNING id, username, password, email, created_at, last_modified, enabled, is_deleted
`

type EnableUserByIdParams struct {
	ID      uuid.UUID
	Enabled bool
}

func (q *Queries) EnableUserById(ctx context.Context, arg EnableUserByIdParams) (User, error) {
	row := q.db.QueryRow(ctx, enableUserById, arg.ID, arg.Enabled)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.CreatedAt,
		&i.LastModified,
		&i.Enabled,
		&i.IsDeleted,
	)
	return i, err
}

const enableUserRoleById = `-- name: EnableUserRoleById :exec
UPDATE user_roles SET "enabled" = TRUE
WHERE id = $1
`

func (q *Queries) EnableUserRoleById(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, enableUserRoleById, id)
	return err
}

const getAllActiveUsers = `-- name: GetAllActiveUsers :many
SELECT
    "id",
    "username",
    "password",
     "email",
    "roles",
    "role_ids",
    "created_at",
    "last_modified",
    "enabled",
    "is_deleted"
FROM public.users_with_roles uwr
`

func (q *Queries) GetAllActiveUsers(ctx context.Context) ([]UsersWithRole, error) {
	rows, err := q.db.Query(ctx, getAllActiveUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsersWithRole
	for rows.Next() {
		var i UsersWithRole
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Password,
			&i.Email,
			&i.Roles,
			&i.RoleIds,
			&i.CreatedAt,
			&i.LastModified,
			&i.Enabled,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllAppPermissions = `-- name: GetAllAppPermissions :many
SELECT id, permission_name, permission_description
FROM public.app_permissions
`

func (q *Queries) GetAllAppPermissions(ctx context.Context) ([]AppPermission, error) {
	rows, err := q.db.Query(ctx, getAllAppPermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppPermission
	for rows.Next() {
		var i AppPermission
		if err := rows.Scan(&i.ID, &i.PermissionName, &i.PermissionDescription); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllExternalApps = `-- name: GetAllExternalApps :many
SELECT id, "name" FROM external_integration_apps
`

type GetAllExternalAppsRow struct {
	ID   uuid.UUID
	Name string
}

func (q *Queries) GetAllExternalApps(ctx context.Context) ([]GetAllExternalAppsRow, error) {
	rows, err := q.db.Query(ctx, getAllExternalApps)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllExternalAppsRow
	for rows.Next() {
		var i GetAllExternalAppsRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllHostServers = `-- name: GetAllHostServers :many
SELECT 
    id,
    hostname,
    ip_address,
    is_container_host,
    is_vm_host,
    is_virtual_machine,
    id_db_host,
    created_at,
    last_modified
FROM public.host_servers
`

type GetAllHostServersRow struct {
	ID               uuid.UUID
	Hostname         string
	IpAddress        netip.Addr
	IsContainerHost  pgtype.Bool
	IsVmHost         pgtype.Bool
	IsVirtualMachine pgtype.Bool
	IDDbHost         pgtype.Bool
	CreatedAt        pgtype.Timestamptz
	LastModified     pgtype.Timestamptz
}

func (q *Queries) GetAllHostServers(ctx context.Context) ([]GetAllHostServersRow, error) {
	rows, err := q.db.Query(ctx, getAllHostServers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllHostServersRow
	for rows.Next() {
		var i GetAllHostServersRow
		if err := rows.Scan(
			&i.ID,
			&i.Hostname,
			&i.IpAddress,
			&i.IsContainerHost,
			&i.IsVmHost,
			&i.IsVirtualMachine,
			&i.IDDbHost,
			&i.CreatedAt,
			&i.LastModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSSHKeyTypes = `-- name: GetAllSSHKeyTypes :many
SELECT 
    id,
    name,
    description,
    created_at,
    last_modified
FROM public.ssh_key_types
`

// SSH Key Types Operations
func (q *Queries) GetAllSSHKeyTypes(ctx context.Context) ([]SshKeyType, error) {
	rows, err := q.db.Query(ctx, getAllSSHKeyTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SshKeyType
	for rows.Next() {
		var i SshKeyType
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.LastModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserPermissions = `-- name: GetAllUserPermissions :many
SELECT
  "UserId",
  "Username",
  "PermissionId",
  "Permission",
  "Role",
  "LastModified"
FROM
    public.user_permissions_view upv
ORDER BY "UserId" ASC
`

func (q *Queries) GetAllUserPermissions(ctx context.Context) ([]UserPermissionsView, error) {
	rows, err := q.db.Query(ctx, getAllUserPermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserPermissionsView
	for rows.Next() {
		var i UserPermissionsView
		if err := rows.Scan(
			&i.UserId,
			&i.Username,
			&i.PermissionId,
			&i.Permission,
			&i.Role,
			&i.LastModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserRoles = `-- name: GetAllUserRoles :many
SELECT "RoleId", "RoleName", "RoleDescription", "CreatedAt", "LastModified", "Enabled", "IsDeleted"
FROM public.user_roles_active
`

func (q *Queries) GetAllUserRoles(ctx context.Context) ([]UserRolesActive, error) {
	rows, err := q.db.Query(ctx, getAllUserRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserRolesActive
	for rows.Next() {
		var i UserRolesActive
		if err := rows.Scan(
			&i.RoleId,
			&i.RoleName,
			&i.RoleDescription,
			&i.CreatedAt,
			&i.LastModified,
			&i.Enabled,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExternalAppIdByName = `-- name: GetExternalAppIdByName :one
SELECT id FROM external_integration_apps WHERE "name" = $1
`

func (q *Queries) GetExternalAppIdByName(ctx context.Context, name string) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getExternalAppIdByName, name)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getExternalAppNameById = `-- name: GetExternalAppNameById :one
SELECT "name" FROM external_integration_apps WHERE id = $1
`

func (q *Queries) GetExternalAppNameById(ctx context.Context, id uuid.UUID) (string, error) {
	row := q.db.QueryRow(ctx, getExternalAppNameById, id)
	var name string
	err := row.Scan(&name)
	return name, err
}

const getExternalApplicationById = `-- name: GetExternalApplicationById :one
SELECT id, "name", created_at, last_modified, endpoint_url, app_description
FROM public.external_integration_apps
WHERE id = $1
`

func (q *Queries) GetExternalApplicationById(ctx context.Context, id uuid.UUID) (ExternalIntegrationApp, error) {
	row := q.db.QueryRow(ctx, getExternalApplicationById, id)
	var i ExternalIntegrationApp
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.LastModified,
		&i.EndpointUrl,
		&i.AppDescription,
	)
	return i, err
}

const getExternalApplicationByName = `-- name: GetExternalApplicationByName :one
SELECT id, "name", created_at, last_modified, endpoint_url, app_description
FROM public.external_integration_apps
WHERE "name" = $1
`

func (q *Queries) GetExternalApplicationByName(ctx context.Context, name string) (ExternalIntegrationApp, error) {
	row := q.db.QueryRow(ctx, getExternalApplicationByName, name)
	var i ExternalIntegrationApp
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.LastModified,
		&i.EndpointUrl,
		&i.AppDescription,
	)
	return i, err
}

const getExternalAuthTokenById = `-- name: GetExternalAuthTokenById :one
SELECT
		id, user_id, external_app_id, token, expiration, created_at, last_modified
 FROM
  	public.external_auth_tokens WHERE id = $1
`

func (q *Queries) GetExternalAuthTokenById(ctx context.Context, id uuid.UUID) (ExternalAuthToken, error) {
	row := q.db.QueryRow(ctx, getExternalAuthTokenById, id)
	var i ExternalAuthToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ExternalAppID,
		&i.Token,
		&i.Expiration,
		&i.CreatedAt,
		&i.LastModified,
	)
	return i, err
}

const getExternalAuthTokensByUserId = `-- name: GetExternalAuthTokensByUserId :many
SELECT
		id, user_id, external_app_id, token, expiration, created_at, last_modified
 FROM
  	public.external_auth_tokens 
WHERE user_id = $1
`

func (q *Queries) GetExternalAuthTokensByUserId(ctx context.Context, userID uuid.UUID) ([]ExternalAuthToken, error) {
	rows, err := q.db.Query(ctx, getExternalAuthTokensByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExternalAuthToken
	for rows.Next() {
		var i ExternalAuthToken
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ExternalAppID,
			&i.Token,
			&i.Expiration,
			&i.CreatedAt,
			&i.LastModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExternalAuthTokensByUserIdAndAppId = `-- name: GetExternalAuthTokensByUserIdAndAppId :many
SELECT
		id, user_id, external_app_id, token, expiration, created_at, last_modified
 FROM
  	public.external_auth_tokens 
WHERE user_id = $1 AND external_app_id = $2
`

type GetExternalAuthTokensByUserIdAndAppIdParams struct {
	UserID        uuid.UUID
	ExternalAppID uuid.UUID
}

func (q *Queries) GetExternalAuthTokensByUserIdAndAppId(ctx context.Context, arg GetExternalAuthTokensByUserIdAndAppIdParams) ([]ExternalAuthToken, error) {
	rows, err := q.db.Query(ctx, getExternalAuthTokensByUserIdAndAppId, arg.UserID, arg.ExternalAppID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExternalAuthToken
	for rows.Next() {
		var i ExternalAuthToken
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ExternalAppID,
			&i.Token,
			&i.Expiration,
			&i.CreatedAt,
			&i.LastModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHostServerByHostname = `-- name: GetHostServerByHostname :one
SELECT 
    id,
    hostname,
    ip_address,
    is_container_host,
    is_vm_host,
    is_virtual_machine,
    id_db_host,
    created_at,
    last_modified
FROM public.host_servers
WHERE hostname = $1
`

type GetHostServerByHostnameRow struct {
	ID               uuid.UUID
	Hostname         string
	IpAddress        netip.Addr
	IsContainerHost  pgtype.Bool
	IsVmHost         pgtype.Bool
	IsVirtualMachine pgtype.Bool
	IDDbHost         pgtype.Bool
	CreatedAt        pgtype.Timestamptz
	LastModified     pgtype.Timestamptz
}

func (q *Queries) GetHostServerByHostname(ctx context.Context, hostname string) (GetHostServerByHostnameRow, error) {
	row := q.db.QueryRow(ctx, getHostServerByHostname, hostname)
	var i GetHostServerByHostnameRow
	err := row.Scan(
		&i.ID,
		&i.Hostname,
		&i.IpAddress,
		&i.IsContainerHost,
		&i.IsVmHost,
		&i.IsVirtualMachine,
		&i.IDDbHost,
		&i.CreatedAt,
		&i.LastModified,
	)
	return i, err
}

const getHostServerByIP = `-- name: GetHostServerByIP :one
SELECT 
    id,
    hostname,
    ip_address,
    is_container_host,
    is_vm_host,
    is_virtual_machine,
    id_db_host,
    created_at,
    last_modified
FROM public.host_servers
WHERE ip_address = $1
`

type GetHostServerByIPRow struct {
	ID               uuid.UUID
	Hostname         string
	IpAddress        netip.Addr
	IsContainerHost  pgtype.Bool
	IsVmHost         pgtype.Bool
	IsVirtualMachine pgtype.Bool
	IDDbHost         pgtype.Bool
	CreatedAt        pgtype.Timestamptz
	LastModified     pgtype.Timestamptz
}

func (q *Queries) GetHostServerByIP(ctx context.Context, ipAddress netip.Addr) (GetHostServerByIPRow, error) {
	row := q.db.QueryRow(ctx, getHostServerByIP, ipAddress)
	var i GetHostServerByIPRow
	err := row.Scan(
		&i.ID,
		&i.Hostname,
		&i.IpAddress,
		&i.IsContainerHost,
		&i.IsVmHost,
		&i.IsVirtualMachine,
		&i.IDDbHost,
		&i.CreatedAt,
		&i.LastModified,
	)
	return i, err
}

const getHostServerById = `-- name: GetHostServerById :one
SELECT 
    id,
    hostname,
    ip_address,
    is_container_host,
    is_vm_host,
    is_virtual_machine,
    id_db_host,
    created_at,
    last_modified
FROM public.host_servers
WHERE id = $1
`

type GetHostServerByIdRow struct {
	ID               uuid.UUID
	Hostname         string
	IpAddress        netip.Addr
	IsContainerHost  pgtype.Bool
	IsVmHost         pgtype.Bool
	IsVirtualMachine pgtype.Bool
	IDDbHost         pgtype.Bool
	CreatedAt        pgtype.Timestamptz
	LastModified     pgtype.Timestamptz
}

// Host Servers CRUD Operations
func (q *Queries) GetHostServerById(ctx context.Context, id uuid.UUID) (GetHostServerByIdRow, error) {
	row := q.db.QueryRow(ctx, getHostServerById, id)
	var i GetHostServerByIdRow
	err := row.Scan(
		&i.ID,
		&i.Hostname,
		&i.IpAddress,
		&i.IsContainerHost,
		&i.IsVmHost,
		&i.IsVirtualMachine,
		&i.IDDbHost,
		&i.CreatedAt,
		&i.LastModified,
	)
	return i, err
}

const getLatestExternalAuthToken = `-- name: GetLatestExternalAuthToken :one
SELECT id, user_id, external_app_id, token, expiration, created_at, last_modified FROM external_auth_tokens
WHERE user_id = $1 AND external_app_id = $2
ORDER BY created_at DESC
LIMIT 1
`

type GetLatestExternalAuthTokenParams struct {
	UserID        uuid.UUID
	ExternalAppID uuid.UUID
}

func (q *Queries) GetLatestExternalAuthToken(ctx context.Context, arg GetLatestExternalAuthTokenParams) (ExternalAuthToken, error) {
	row := q.db.QueryRow(ctx, getLatestExternalAuthToken, arg.UserID, arg.ExternalAppID)
	var i ExternalAuthToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ExternalAppID,
		&i.Token,
		&i.Expiration,
		&i.CreatedAt,
		&i.LastModified,
	)
	return i, err
}

const getLatestExternalAuthTokenByAppName = `-- name: GetLatestExternalAuthTokenByAppName :one
SELECT et.id, et.user_id, et.external_app_id, ea.name 
FROM external_auth_tokens et 
LEFT JOIN public.external_integration_apps ea on et.external_app_id = ea.id
WHERE et.user_id = $1 AND ea.name = $2
ORDER BY et.created_at DESC
LIMIT 1
`

type GetLatestExternalAuthTokenByAppNameParams struct {
	UserID uuid.UUID
	Name   string
}

type GetLatestExternalAuthTokenByAppNameRow struct {
	ID            uuid.UUID
	UserID        uuid.UUID
	ExternalAppID uuid.UUID
	Name          pgtype.Text
}

func (q *Queries) GetLatestExternalAuthTokenByAppName(ctx context.Context, arg GetLatestExternalAuthTokenByAppNameParams) (GetLatestExternalAuthTokenByAppNameRow, error) {
	row := q.db.QueryRow(ctx, getLatestExternalAuthTokenByAppName, arg.UserID, arg.Name)
	var i GetLatestExternalAuthTokenByAppNameRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ExternalAppID,
		&i.Name,
	)
	return i, err
}

const getRoleIdByName = `-- name: GetRoleIdByName :one
SELECT
  "id" AS "RoleId"
FROM
  public. public.user_roles
WHERE "role_name" = $1
`

func (q *Queries) GetRoleIdByName(ctx context.Context, roleName string) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getRoleIdByName, roleName)
	var RoleId uuid.UUID
	err := row.Scan(&RoleId)
	return RoleId, err
}

const getSSHKeyById = `-- name: GetSSHKeyById :one
SELECT 
    sk.id,
    sk.name,
    sk.description,
    sk.priv_secret_id,
    sk.public_key,
    sk.key_type_id,
    sk.owner_user_id,
    sk.created_at,
    sk.last_modified,
    skt.name as key_type_name,
    skt.description as key_type_description,
    u.username as owner_username
FROM public.ssh_keys sk
JOIN public.ssh_key_types skt ON sk.key_type_id = skt.id
JOIN public.users u ON sk.owner_user_id = u.id
WHERE sk.id = $1
`

type GetSSHKeyByIdRow struct {
	ID                 uuid.UUID
	Name               string
	Description        pgtype.Text
	PrivSecretID       pgtype.UUID
	PublicKey          string
	KeyTypeID          uuid.UUID
	OwnerUserID        uuid.UUID
	CreatedAt          pgtype.Timestamptz
	LastModified       pgtype.Timestamptz
	KeyTypeName        string
	KeyTypeDescription pgtype.Text
	OwnerUsername      pgtype.Text
}

func (q *Queries) GetSSHKeyById(ctx context.Context, id uuid.UUID) (GetSSHKeyByIdRow, error) {
	row := q.db.QueryRow(ctx, getSSHKeyById, id)
	var i GetSSHKeyByIdRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.PrivSecretID,
		&i.PublicKey,
		&i.KeyTypeID,
		&i.OwnerUserID,
		&i.CreatedAt,
		&i.LastModified,
		&i.KeyTypeName,
		&i.KeyTypeDescription,
		&i.OwnerUsername,
	)
	return i, err
}

const getSSHKeyHostMappingById = `-- name: GetSSHKeyHostMappingById :one
SELECT 
    id,
    host_server_id,
    ssh_key_id,
    user_id,
    hostserver_username,
    sudo_password_token_id,
    created_at,
    last_modified
FROM public.host_server_ssh_mappings
WHERE id = $1
`

type GetSSHKeyHostMappingByIdRow struct {
	ID                  uuid.UUID
	HostServerID        uuid.UUID
	SshKeyID            uuid.UUID
	UserID              uuid.UUID
	HostserverUsername  string
	SudoPasswordTokenID pgtype.UUID
	CreatedAt           pgtype.Timestamptz
	LastModified        pgtype.Timestamptz
}

func (q *Queries) GetSSHKeyHostMappingById(ctx context.Context, id uuid.UUID) (GetSSHKeyHostMappingByIdRow, error) {
	row := q.db.QueryRow(ctx, getSSHKeyHostMappingById, id)
	var i GetSSHKeyHostMappingByIdRow
	err := row.Scan(
		&i.ID,
		&i.HostServerID,
		&i.SshKeyID,
		&i.UserID,
		&i.HostserverUsername,
		&i.SudoPasswordTokenID,
		&i.CreatedAt,
		&i.LastModified,
	)
	return i, err
}

const getSSHKeyHostMappingsByHostId = `-- name: GetSSHKeyHostMappingsByHostId :many
SELECT 
    mapping_id,
    user_id,
    username,
    host_server_name,
    host_server_id,
    public_key,
    ssh_key_id,
    external_auth_token_id,
    ssh_key_type,
    hostserver_username,
    sudo_password_token_id,
    created_at,
    last_modified
FROM public.user_ssh_key_mappings
WHERE host_server_id = $1
`

func (q *Queries) GetSSHKeyHostMappingsByHostId(ctx context.Context, hostServerID uuid.UUID) ([]UserSshKeyMapping, error) {
	rows, err := q.db.Query(ctx, getSSHKeyHostMappingsByHostId, hostServerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserSshKeyMapping
	for rows.Next() {
		var i UserSshKeyMapping
		if err := rows.Scan(
			&i.MappingID,
			&i.UserID,
			&i.Username,
			&i.HostServerName,
			&i.HostServerID,
			&i.PublicKey,
			&i.SshKeyID,
			&i.ExternalAuthTokenID,
			&i.SshKeyType,
			&i.HostserverUsername,
			&i.SudoPasswordTokenID,
			&i.CreatedAt,
			&i.LastModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSSHKeyHostMappingsByKeyId = `-- name: GetSSHKeyHostMappingsByKeyId :many
SELECT 
    mapping_id,
    user_id,
    username,
    host_server_name,
    host_server_id,
    public_key,
    ssh_key_id,
    external_auth_token_id,
    ssh_key_type,
    hostserver_username,
    sudo_password_token_id,
    created_at,
    last_modified
FROM public.user_ssh_key_mappings
WHERE ssh_key_id = $1
`

func (q *Queries) GetSSHKeyHostMappingsByKeyId(ctx context.Context, sshKeyID uuid.UUID) ([]UserSshKeyMapping, error) {
	rows, err := q.db.Query(ctx, getSSHKeyHostMappingsByKeyId, sshKeyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserSshKeyMapping
	for rows.Next() {
		var i UserSshKeyMapping
		if err := rows.Scan(
			&i.MappingID,
			&i.UserID,
			&i.Username,
			&i.HostServerName,
			&i.HostServerID,
			&i.PublicKey,
			&i.SshKeyID,
			&i.ExternalAuthTokenID,
			&i.SshKeyType,
			&i.HostserverUsername,
			&i.SudoPasswordTokenID,
			&i.CreatedAt,
			&i.LastModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSSHKeyHostMappingsByUserId = `-- name: GetSSHKeyHostMappingsByUserId :many
SELECT 
    mapping_id,
    user_id,
    username,
    host_server_name,
    host_server_id,
    public_key,
    ssh_key_id,
    external_auth_token_id,
    ssh_key_type,
    hostserver_username,
    sudo_password_token_id,
    created_at,
    last_modified
FROM public.user_ssh_key_mappings
WHERE user_id = $1
`

func (q *Queries) GetSSHKeyHostMappingsByUserId(ctx context.Context, userID uuid.UUID) ([]UserSshKeyMapping, error) {
	rows, err := q.db.Query(ctx, getSSHKeyHostMappingsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserSshKeyMapping
	for rows.Next() {
		var i UserSshKeyMapping
		if err := rows.Scan(
			&i.MappingID,
			&i.UserID,
			&i.Username,
			&i.HostServerName,
			&i.HostServerID,
			&i.PublicKey,
			&i.SshKeyID,
			&i.ExternalAuthTokenID,
			&i.SshKeyType,
			&i.HostserverUsername,
			&i.SudoPasswordTokenID,
			&i.CreatedAt,
			&i.LastModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSSHKeyTypeByName = `-- name: GetSSHKeyTypeByName :one
SELECT 
    id,
    name,
    description,
    created_at,
    last_modified
FROM public.ssh_key_types
WHERE name = $1
`

func (q *Queries) GetSSHKeyTypeByName(ctx context.Context, name string) (SshKeyType, error) {
	row := q.db.QueryRow(ctx, getSSHKeyTypeByName, name)
	var i SshKeyType
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.LastModified,
	)
	return i, err
}

const getSSHKeysByOwnerId = `-- name: GetSSHKeysByOwnerId :many
SELECT 
    sk.id,
    sk.name,
    sk.description,
    sk.priv_secret_id,
    sk.public_key,
    sk.key_type_id,
    sk.owner_user_id,
    sk.created_at,
    sk.last_modified,
    skt.name as key_type_name,
    skt.description as key_type_description,
    u.username as owner_username
FROM public.ssh_keys sk
JOIN public.ssh_key_types skt ON sk.key_type_id = skt.id
JOIN public.users u ON sk.owner_user_id = u.id
WHERE sk.owner_user_id = $1
`

type GetSSHKeysByOwnerIdRow struct {
	ID                 uuid.UUID
	Name               string
	Description        pgtype.Text
	PrivSecretID       pgtype.UUID
	PublicKey          string
	KeyTypeID          uuid.UUID
	OwnerUserID        uuid.UUID
	CreatedAt          pgtype.Timestamptz
	LastModified       pgtype.Timestamptz
	KeyTypeName        string
	KeyTypeDescription pgtype.Text
	OwnerUsername      pgtype.Text
}

func (q *Queries) GetSSHKeysByOwnerId(ctx context.Context, ownerUserID uuid.UUID) ([]GetSSHKeysByOwnerIdRow, error) {
	rows, err := q.db.Query(ctx, getSSHKeysByOwnerId, ownerUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSSHKeysByOwnerIdRow
	for rows.Next() {
		var i GetSSHKeysByOwnerIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.PrivSecretID,
			&i.PublicKey,
			&i.KeyTypeID,
			&i.OwnerUserID,
			&i.CreatedAt,
			&i.LastModified,
			&i.KeyTypeName,
			&i.KeyTypeDescription,
			&i.OwnerUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserById = `-- name: GetUserById :one
SELECT
    "id",
    "username",
    "password",
    "email",
    "roles",
    "role_ids",
    "created_at",
    "last_modified",
    "enabled",
    "is_deleted"
FROM public.users_with_roles uwr
WHERE "id" = $1
`

func (q *Queries) GetUserById(ctx context.Context, id uuid.UUID) (UsersWithRole, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i UsersWithRole
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.Roles,
		&i.RoleIds,
		&i.CreatedAt,
		&i.LastModified,
		&i.Enabled,
		&i.IsDeleted,
	)
	return i, err
}

const getUserByName = `-- name: GetUserByName :one
SELECT
    "id",
    "username",
    "password",
    "email",
    "roles",
    "role_ids",
    "created_at",
    "last_modified",
    "enabled",
    "is_deleted"
FROM public.users_with_roles uwr
WHERE username = $1
`

func (q *Queries) GetUserByName(ctx context.Context, username pgtype.Text) (UsersWithRole, error) {
	row := q.db.QueryRow(ctx, getUserByName, username)
	var i UsersWithRole
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.Roles,
		&i.RoleIds,
		&i.CreatedAt,
		&i.LastModified,
		&i.Enabled,
		&i.IsDeleted,
	)
	return i, err
}

const getUserIdByName = `-- name: GetUserIdByName :one
SELECT
	id
FROM public.users
where username = $1
`

func (q *Queries) GetUserIdByName(ctx context.Context, username pgtype.Text) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getUserIdByName, username)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getUserLogin = `-- name: GetUserLogin :one
SELECT id, username, "password" , email, "enabled", "roles", "role_ids" FROM public.users_with_roles uwr
WHERE username = $1 OR email = $1
LIMIT 1
`

type GetUserLoginRow struct {
	ID       uuid.UUID
	Username pgtype.Text
	Password pgtype.Text
	Email    pgtype.Text
	Enabled  bool
	Roles    []string
	RoleIds  uuid.UUIDs
}

func (q *Queries) GetUserLogin(ctx context.Context, username pgtype.Text) (GetUserLoginRow, error) {
	row := q.db.QueryRow(ctx, getUserLogin, username)
	var i GetUserLoginRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.Enabled,
		&i.Roles,
		&i.RoleIds,
	)
	return i, err
}

const getUserNameById = `-- name: GetUserNameById :one
SELECT
  "username"
FROM public.users
WHERE id = $1
`

func (q *Queries) GetUserNameById(ctx context.Context, id uuid.UUID) (pgtype.Text, error) {
	row := q.db.QueryRow(ctx, getUserNameById, id)
	var username pgtype.Text
	err := row.Scan(&username)
	return username, err
}

const getUserPermissionsById = `-- name: GetUserPermissionsById :many
SELECT
  "UserId",
  "Username",
  "PermissionId",
  "Permission",
  "Role",
  "LastModified"
FROM
    public.user_permissions_view upv
WHERE "UserId" = $1
`

func (q *Queries) GetUserPermissionsById(ctx context.Context, userid pgtype.UUID) ([]UserPermissionsView, error) {
	rows, err := q.db.Query(ctx, getUserPermissionsById, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserPermissionsView
	for rows.Next() {
		var i UserPermissionsView
		if err := rows.Scan(
			&i.UserId,
			&i.Username,
			&i.PermissionId,
			&i.Permission,
			&i.Role,
			&i.LastModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSecretsByAppId = `-- name: GetUserSecretsByAppId :many
SELECT
  auth_token_id,
  user_id,
  application_id,
  username,
  endpoint_url,
  email,
  application_name,
  token_created_at,
  expiration
FROM public.user_auth_app_mappings
WHERE user_id = $1 AND application_id = $2
`

type GetUserSecretsByAppIdParams struct {
	UserID        uuid.UUID
	ApplicationID uuid.UUID
}

type GetUserSecretsByAppIdRow struct {
	AuthTokenID     uuid.UUID
	UserID          uuid.UUID
	ApplicationID   uuid.UUID
	Username        pgtype.Text
	EndpointUrl     pgtype.Text
	Email           pgtype.Text
	ApplicationName string
	TokenCreatedAt  pgtype.Timestamptz
	Expiration      pgtype.Timestamptz
}

func (q *Queries) GetUserSecretsByAppId(ctx context.Context, arg GetUserSecretsByAppIdParams) ([]GetUserSecretsByAppIdRow, error) {
	rows, err := q.db.Query(ctx, getUserSecretsByAppId, arg.UserID, arg.ApplicationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserSecretsByAppIdRow
	for rows.Next() {
		var i GetUserSecretsByAppIdRow
		if err := rows.Scan(
			&i.AuthTokenID,
			&i.UserID,
			&i.ApplicationID,
			&i.Username,
			&i.EndpointUrl,
			&i.Email,
			&i.ApplicationName,
			&i.TokenCreatedAt,
			&i.Expiration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSecretsByAppName = `-- name: GetUserSecretsByAppName :many
SELECT
  auth_token_id,
  user_id,
  application_id,
  username,
  endpoint_url,
  email,
  application_name,
  token_created_at,
  expiration
FROM public.user_auth_app_mappings
WHERE user_id = $1 AND application_name = $2
`

type GetUserSecretsByAppNameParams struct {
	UserID          uuid.UUID
	ApplicationName string
}

type GetUserSecretsByAppNameRow struct {
	AuthTokenID     uuid.UUID
	UserID          uuid.UUID
	ApplicationID   uuid.UUID
	Username        pgtype.Text
	EndpointUrl     pgtype.Text
	Email           pgtype.Text
	ApplicationName string
	TokenCreatedAt  pgtype.Timestamptz
	Expiration      pgtype.Timestamptz
}

func (q *Queries) GetUserSecretsByAppName(ctx context.Context, arg GetUserSecretsByAppNameParams) ([]GetUserSecretsByAppNameRow, error) {
	rows, err := q.db.Query(ctx, getUserSecretsByAppName, arg.UserID, arg.ApplicationName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserSecretsByAppNameRow
	for rows.Next() {
		var i GetUserSecretsByAppNameRow
		if err := rows.Scan(
			&i.AuthTokenID,
			&i.UserID,
			&i.ApplicationID,
			&i.Username,
			&i.EndpointUrl,
			&i.Email,
			&i.ApplicationName,
			&i.TokenCreatedAt,
			&i.Expiration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSecretsByUserId = `-- name: GetUserSecretsByUserId :many
SELECT
  auth_token_id,
  user_id,
  application_id,
  username,
  endpoint_url,
  email,
  application_name,
  token_created_at,
  expiration
FROM public.user_auth_app_mappings
WHERE user_id = $1
`

type GetUserSecretsByUserIdRow struct {
	AuthTokenID     uuid.UUID
	UserID          uuid.UUID
	ApplicationID   uuid.UUID
	Username        pgtype.Text
	EndpointUrl     pgtype.Text
	Email           pgtype.Text
	ApplicationName string
	TokenCreatedAt  pgtype.Timestamptz
	Expiration      pgtype.Timestamptz
}

func (q *Queries) GetUserSecretsByUserId(ctx context.Context, userID uuid.UUID) ([]GetUserSecretsByUserIdRow, error) {
	rows, err := q.db.Query(ctx, getUserSecretsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserSecretsByUserIdRow
	for rows.Next() {
		var i GetUserSecretsByUserIdRow
		if err := rows.Scan(
			&i.AuthTokenID,
			&i.UserID,
			&i.ApplicationID,
			&i.Username,
			&i.EndpointUrl,
			&i.Email,
			&i.ApplicationName,
			&i.TokenCreatedAt,
			&i.Expiration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hardDeleteUserRoleById = `-- name: HardDeleteUserRoleById :exec
DELETE FROM user_roles
WHERE id = $1
`

func (q *Queries) HardDeleteUserRoleById(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, hardDeleteUserRoleById, id)
	return err
}

const insertExternalAppIntegrationByName = `-- name: InsertExternalAppIntegrationByName :one
INSERT INTO public.external_integration_apps (id, "name") 
VALUES ($1, $2)
RETURNING id, name, created_at, last_modified, endpoint_url, app_description
`

type InsertExternalAppIntegrationByNameParams struct {
	ID   uuid.UUID
	Name string
}

func (q *Queries) InsertExternalAppIntegrationByName(ctx context.Context, arg InsertExternalAppIntegrationByNameParams) (ExternalIntegrationApp, error) {
	row := q.db.QueryRow(ctx, insertExternalAppIntegrationByName, arg.ID, arg.Name)
	var i ExternalIntegrationApp
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.LastModified,
		&i.EndpointUrl,
		&i.AppDescription,
	)
	return i, err
}

const insertExternalAuthToken = `-- name: InsertExternalAuthToken :one
INSERT INTO public.external_auth_tokens (
    id,
    user_id,
    external_app_id,
    token,
    expiration
)
VALUES (
  gen_random_uuid(),  $1, $2, $3, $4
)
RETURNING id
`

type InsertExternalAuthTokenParams struct {
	UserID        uuid.UUID
	ExternalAppID uuid.UUID
	Token         []byte
	Expiration    pgtype.Timestamptz
}

func (q *Queries) InsertExternalAuthToken(ctx context.Context, arg InsertExternalAuthTokenParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, insertExternalAuthToken,
		arg.UserID,
		arg.ExternalAppID,
		arg.Token,
		arg.Expiration,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const insertOrUpdateAppPermission = `-- name: InsertOrUpdateAppPermission :one
INSERT INTO app_permissions(id, permission_name, permission_description)
VALUES(gen_random_uuid(), $1, $2)
ON CONFLICT (permission_name)
DO UPDATE SET
	permission_description = EXCLUDED.permission_description
RETURNING id, permission_name, permission_description
`

type InsertOrUpdateAppPermissionParams struct {
	PermissionName        string
	PermissionDescription pgtype.Text
}

func (q *Queries) InsertOrUpdateAppPermission(ctx context.Context, arg InsertOrUpdateAppPermissionParams) (AppPermission, error) {
	row := q.db.QueryRow(ctx, insertOrUpdateAppPermission, arg.PermissionName, arg.PermissionDescription)
	var i AppPermission
	err := row.Scan(&i.ID, &i.PermissionName, &i.PermissionDescription)
	return i, err
}

const insertOrUpdateRolePermissionMapping = `-- name: InsertOrUpdateRolePermissionMapping :one
INSERT INTO role_permission_mapping(id, role_id, permission_id, "enabled", created_at, last_modified)
VALUES(gen_random_uuid(), $1, $2, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
ON CONFLICT(role_id, permission_id)
DO UPDATE SET
  role_id = EXCLUDED.role_id,
  permission_id = EXCLUDED.permission_id,
  "enabled" = true,
  created_at = CURRENT_TIMESTAMP,
  last_modified = CURRENT_TIMESTAMP
RETURNING id, role_id, permission_id, enabled, created_at, last_modified
`

type InsertOrUpdateRolePermissionMappingParams struct {
	RoleID       uuid.UUID
	PermissionID uuid.UUID
}

func (q *Queries) InsertOrUpdateRolePermissionMapping(ctx context.Context, arg InsertOrUpdateRolePermissionMappingParams) (RolePermissionMapping, error) {
	row := q.db.QueryRow(ctx, insertOrUpdateRolePermissionMapping, arg.RoleID, arg.PermissionID)
	var i RolePermissionMapping
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.PermissionID,
		&i.Enabled,
		&i.CreatedAt,
		&i.LastModified,
	)
	return i, err
}

const insertOrUpdateUserRole = `-- name: InsertOrUpdateUserRole :one
INSERT INTO user_roles (id, role_name, role_description, created_at, last_modified, "enabled", "is_deleted")
VALUES(gen_random_uuid(), $1, $2, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, TRUE, false)
ON CONFLICT (role_name)
DO UPDATE SET
	role_description = EXCLUDED.role_description,
	last_modified = CURRENT_TIMESTAMP,
	"enabled" = TRUE,
	"is_deleted" = FALSE
RETURNING id, role_name, role_description, created_at, last_modified, enabled, is_deleted
`

type InsertOrUpdateUserRoleParams struct {
	RoleName        string
	RoleDescription pgtype.Text
}

func (q *Queries) InsertOrUpdateUserRole(ctx context.Context, arg InsertOrUpdateUserRoleParams) (UserRole, error) {
	row := q.db.QueryRow(ctx, insertOrUpdateUserRole, arg.RoleName, arg.RoleDescription)
	var i UserRole
	err := row.Scan(
		&i.ID,
		&i.RoleName,
		&i.RoleDescription,
		&i.CreatedAt,
		&i.LastModified,
		&i.Enabled,
		&i.IsDeleted,
	)
	return i, err
}

const insertOrUpdateUserRoleMappingById = `-- name: InsertOrUpdateUserRoleMappingById :one
INSERT INTO public.user_role_mapping(user_id, role_id, enabled)
VALUES ($1, $2, TRUE)
ON CONFLICT (user_id, role_id)
DO UPDATE SET enabled = TRUE
RETURNING id, user_id, role_id, enabled, created_at, last_modified
`

type InsertOrUpdateUserRoleMappingByIdParams struct {
	UserID uuid.UUID
	RoleID uuid.UUID
}

func (q *Queries) InsertOrUpdateUserRoleMappingById(ctx context.Context, arg InsertOrUpdateUserRoleMappingByIdParams) (UserRoleMapping, error) {
	row := q.db.QueryRow(ctx, insertOrUpdateUserRoleMappingById, arg.UserID, arg.RoleID)
	var i UserRoleMapping
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RoleID,
		&i.Enabled,
		&i.CreatedAt,
		&i.LastModified,
	)
	return i, err
}

const insertUserHostedDb = `-- name: InsertUserHostedDb :one
INSERT INTO public.user_hosted_db (
  price_tier_code_id,
  user_id,
  current_host_server_id,
  current_kube_cluster_id,
  user_application_ids,
  db_platform_id,
  fqdn,
  pub_ip_address,
  listen_port,
  private_ip_address,
  created_at,
  last_modified)
VALUES ($1, $2, $3, $4, $5, $6, $6, $7, $7, $8, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
RETURNING id, price_tier_code_id, user_id, current_host_server_id, current_kube_cluster_id, user_application_ids, db_platform_id, fqdn, pub_ip_address, listen_port, private_ip_address, created_at, last_modified
`

type InsertUserHostedDbParams struct {
	PriceTierCodeID      int32
	UserID               int32
	CurrentHostServerID  int32
	CurrentKubeClusterID pgtype.Int4
	UserApplicationIds   []int32
	DbPlatformID         int32
	PubIpAddress         netip.Addr
	PrivateIpAddress     *netip.Addr
}

func (q *Queries) InsertUserHostedDb(ctx context.Context, arg InsertUserHostedDbParams) (UserHostedDb, error) {
	row := q.db.QueryRow(ctx, insertUserHostedDb,
		arg.PriceTierCodeID,
		arg.UserID,
		arg.CurrentHostServerID,
		arg.CurrentKubeClusterID,
		arg.UserApplicationIds,
		arg.DbPlatformID,
		arg.PubIpAddress,
		arg.PrivateIpAddress,
	)
	var i UserHostedDb
	err := row.Scan(
		&i.ID,
		&i.PriceTierCodeID,
		&i.UserID,
		&i.CurrentHostServerID,
		&i.CurrentKubeClusterID,
		&i.UserApplicationIds,
		&i.DbPlatformID,
		&i.Fqdn,
		&i.PubIpAddress,
		&i.ListenPort,
		&i.PrivateIpAddress,
		&i.CreatedAt,
		&i.LastModified,
	)
	return i, err
}

const softDeleteUserById = `-- name: SoftDeleteUserById :one
UPDATE users
  set is_deleted = TRUE,
  "enabled" = FALSE
WHERE id = $1
RETURNING id, username, password, email, created_at, last_modified, enabled, is_deleted
`

func (q *Queries) SoftDeleteUserById(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, softDeleteUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.CreatedAt,
		&i.LastModified,
		&i.Enabled,
		&i.IsDeleted,
	)
	return i, err
}

const softDeleteUserRoleById = `-- name: SoftDeleteUserRoleById :exec
UPDATE user_roles
SET
"is_deleted" = TRUE,
"enabled" = FALSE
WHERE id = $1
`

func (q *Queries) SoftDeleteUserRoleById(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteUserRoleById, id)
	return err
}

const updateExternalApplication = `-- name: UpdateExternalApplication :one
UPDATE public.external_integration_apps
SET 
    "name" = COALESCE($2, "name"),
    endpoint_url = COALESCE($3, endpoint_url),
    app_description = COALESCE($4, app_description),
    last_modified = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, "name", created_at, last_modified, endpoint_url, app_description
`

type UpdateExternalApplicationParams struct {
	ID             uuid.UUID
	Name           string
	EndpointUrl    pgtype.Text
	AppDescription pgtype.Text
}

func (q *Queries) UpdateExternalApplication(ctx context.Context, arg UpdateExternalApplicationParams) (ExternalIntegrationApp, error) {
	row := q.db.QueryRow(ctx, updateExternalApplication,
		arg.ID,
		arg.Name,
		arg.EndpointUrl,
		arg.AppDescription,
	)
	var i ExternalIntegrationApp
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.LastModified,
		&i.EndpointUrl,
		&i.AppDescription,
	)
	return i, err
}

const updateHostServer = `-- name: UpdateHostServer :one
UPDATE public.host_servers
SET 
    hostname = COALESCE($2, hostname),
    ip_address = COALESCE($3, ip_address),
    is_container_host = COALESCE($4, is_container_host),
    is_vm_host = COALESCE($5, is_vm_host),
    is_virtual_machine = COALESCE($6, is_virtual_machine),
    id_db_host = COALESCE($7, id_db_host),
    last_modified = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, hostname, ip_address, is_container_host, is_vm_host, is_virtual_machine, id_db_host, created_at, last_modified
`

type UpdateHostServerParams struct {
	ID               uuid.UUID
	Hostname         string
	IpAddress        netip.Addr
	IsContainerHost  pgtype.Bool
	IsVmHost         pgtype.Bool
	IsVirtualMachine pgtype.Bool
	IDDbHost         pgtype.Bool
}

type UpdateHostServerRow struct {
	ID               uuid.UUID
	Hostname         string
	IpAddress        netip.Addr
	IsContainerHost  pgtype.Bool
	IsVmHost         pgtype.Bool
	IsVirtualMachine pgtype.Bool
	IDDbHost         pgtype.Bool
	CreatedAt        pgtype.Timestamptz
	LastModified     pgtype.Timestamptz
}

func (q *Queries) UpdateHostServer(ctx context.Context, arg UpdateHostServerParams) (UpdateHostServerRow, error) {
	row := q.db.QueryRow(ctx, updateHostServer,
		arg.ID,
		arg.Hostname,
		arg.IpAddress,
		arg.IsContainerHost,
		arg.IsVmHost,
		arg.IsVirtualMachine,
		arg.IDDbHost,
	)
	var i UpdateHostServerRow
	err := row.Scan(
		&i.ID,
		&i.Hostname,
		&i.IpAddress,
		&i.IsContainerHost,
		&i.IsVmHost,
		&i.IsVirtualMachine,
		&i.IDDbHost,
		&i.CreatedAt,
		&i.LastModified,
	)
	return i, err
}

const updateSSHKey = `-- name: UpdateSSHKey :one
UPDATE public.ssh_keys
SET 
    name = COALESCE($2, name),
    description = COALESCE($3, description),
    public_key = COALESCE($4, public_key),
    key_type_id = COALESCE($5, key_type_id),
    last_modified = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, name, description, priv_secret_id, public_key, key_type_id, owner_user_id, created_at, last_modified
`

type UpdateSSHKeyParams struct {
	ID          uuid.UUID
	Name        string
	Description pgtype.Text
	PublicKey   string
	KeyTypeID   uuid.UUID
}

type UpdateSSHKeyRow struct {
	ID           uuid.UUID
	Name         string
	Description  pgtype.Text
	PrivSecretID pgtype.UUID
	PublicKey    string
	KeyTypeID    uuid.UUID
	OwnerUserID  uuid.UUID
	CreatedAt    pgtype.Timestamptz
	LastModified pgtype.Timestamptz
}

func (q *Queries) UpdateSSHKey(ctx context.Context, arg UpdateSSHKeyParams) (UpdateSSHKeyRow, error) {
	row := q.db.QueryRow(ctx, updateSSHKey,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.PublicKey,
		arg.KeyTypeID,
	)
	var i UpdateSSHKeyRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.PrivSecretID,
		&i.PublicKey,
		&i.KeyTypeID,
		&i.OwnerUserID,
		&i.CreatedAt,
		&i.LastModified,
	)
	return i, err
}

const updateSSHKeyHostMapping = `-- name: UpdateSSHKeyHostMapping :one
UPDATE public.host_server_ssh_mappings
SET 
    hostserver_username = $2,
    last_modified = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, host_server_id, ssh_key_id, user_id, hostserver_username, sudo_password_token_id, created_at, last_modified
`

type UpdateSSHKeyHostMappingParams struct {
	ID                 uuid.UUID
	HostserverUsername string
}

type UpdateSSHKeyHostMappingRow struct {
	ID                  uuid.UUID
	HostServerID        uuid.UUID
	SshKeyID            uuid.UUID
	UserID              uuid.UUID
	HostserverUsername  string
	SudoPasswordTokenID pgtype.UUID
	CreatedAt           pgtype.Timestamptz
	LastModified        pgtype.Timestamptz
}

func (q *Queries) UpdateSSHKeyHostMapping(ctx context.Context, arg UpdateSSHKeyHostMappingParams) (UpdateSSHKeyHostMappingRow, error) {
	row := q.db.QueryRow(ctx, updateSSHKeyHostMapping, arg.ID, arg.HostserverUsername)
	var i UpdateSSHKeyHostMappingRow
	err := row.Scan(
		&i.ID,
		&i.HostServerID,
		&i.SshKeyID,
		&i.UserID,
		&i.HostserverUsername,
		&i.SudoPasswordTokenID,
		&i.CreatedAt,
		&i.LastModified,
	)
	return i, err
}

const updateSSHKeyType = `-- name: UpdateSSHKeyType :one
UPDATE public.ssh_key_types
SET 
    description = COALESCE($2, description),
    last_modified = CURRENT_TIMESTAMP
WHERE name = $1
RETURNING id, name, description, created_at, last_modified
`

type UpdateSSHKeyTypeParams struct {
	Name        string
	Description pgtype.Text
}

func (q *Queries) UpdateSSHKeyType(ctx context.Context, arg UpdateSSHKeyTypeParams) (SshKeyType, error) {
	row := q.db.QueryRow(ctx, updateSSHKeyType, arg.Name, arg.Description)
	var i SshKeyType
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.LastModified,
	)
	return i, err
}

const updateUserEmailById = `-- name: UpdateUserEmailById :one
UPDATE users
  set email = $2
WHERE id = $1
RETURNING id, username, password, email, created_at, last_modified, enabled, is_deleted
`

type UpdateUserEmailByIdParams struct {
	ID    uuid.UUID
	Email pgtype.Text
}

func (q *Queries) UpdateUserEmailById(ctx context.Context, arg UpdateUserEmailByIdParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserEmailById, arg.ID, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.CreatedAt,
		&i.LastModified,
		&i.Enabled,
		&i.IsDeleted,
	)
	return i, err
}

const updateUserPasswordById = `-- name: UpdateUserPasswordById :exec
UPDATE users
  set password = $2
WHERE id = $1
`

type UpdateUserPasswordByIdParams struct {
	ID       uuid.UUID
	Password pgtype.Text
}

func (q *Queries) UpdateUserPasswordById(ctx context.Context, arg UpdateUserPasswordByIdParams) error {
	_, err := q.db.Exec(ctx, updateUserPasswordById, arg.ID, arg.Password)
	return err
}

const verifyUserPermissionById = `-- name: VerifyUserPermissionById :one
SELECT EXISTS (
  SELECT
    "UserId",
    "Username",
    "PermissionId",
    "Permission",
    "Role",
    "LastModified"
  FROM
      public.user_permissions_view upv
  WHERE "UserId" = $1 and "Permission" = $2
)
`

type VerifyUserPermissionByIdParams struct {
	UserId     pgtype.UUID
	Permission pgtype.Text
}

func (q *Queries) VerifyUserPermissionById(ctx context.Context, arg VerifyUserPermissionByIdParams) (bool, error) {
	row := q.db.QueryRow(ctx, verifyUserPermissionById, arg.UserId, arg.Permission)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const verifyUserPermissionByRoleId = `-- name: VerifyUserPermissionByRoleId :one
SELECT EXISTS (
  SELECT
    "RoleId",
    "Role",
    "PermissionId",
    "Permission",
    "Role"
  FROM
      public.role_permissions_view rpv
  WHERE "RoleId" = $1 and "Permission" = $2
)
`

type VerifyUserPermissionByRoleIdParams struct {
	RoleId     uuid.UUID
	Permission pgtype.Text
}

func (q *Queries) VerifyUserPermissionByRoleId(ctx context.Context, arg VerifyUserPermissionByRoleIdParams) (bool, error) {
	row := q.db.QueryRow(ctx, verifyUserPermissionByRoleId, arg.RoleId, arg.Permission)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
